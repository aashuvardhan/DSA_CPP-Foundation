/*

You are given two integer arrays a[] and b[] of equal size. A sum combination is formed by adding one element from a[] and one from b[], using each index pair (i, j) at most once. Return the top k maximum sum combinations, sorted in non-increasing order.

Examples:

Input: a[] = [3, 2], b[] = [1, 4], k = 2
Output: [7, 6]
Explanation: Possible sums: 3 + 1 = 4, 3 + 4 = 7, 2 + 1 = 3, 2 + 4 = 6, Top 2 sums are 7 and 6.


Input: a[] = [1, 4, 2, 3], b[] = [2, 5, 1, 6], k = 3
Output: [10, 9, 9]
Explanation: The top 3 maximum possible sums are : 4 + 6 = 10, 3 + 6 = 9, and 4 + 5 = 9

Constraints:
1 ≤ a.size() = b.size() ≤ 105
1 ≤ k ≤ a.size()
1 ≤ a[i], b[i] ≤ 104


*/
#include <bits/stdc++.h>
using namespace std;

int main() {
	// your code goes here
	vector<int> v1={4, 2, 5, 1};
	vector<int> v2={ 8, 0, 3, 5};
	int k=3;
	int n=4;
	
	sort(v1.begin(),v1.end());
	sort(v2.begin(),v2.end());
	
	priority_queue<vector<int>> pq;
	
	pq.push({v1[n-1]+v2[n-1],n-1,n-1});
	
	string strg=to_string(n-1)+to_string(n-1);
	
	unordered_set<string> st;
	st.insert(strg);
	
	while(pq.size()!=0 and k>0){
	    vector<int> curr=pq.top();
	    pq.pop();
	    
	    cout<<curr[0]<<endl;
	    k--;
	    int ind1=curr[1];
	    int ind2=curr[2];
	    
	    
	    
	    
	    if(ind1>=0 and (ind2-1)>=0){
	        strg=to_string(ind1)+to_string(ind2-1);
	        if(st.find(strg)==st.end()){
	            st.insert(strg);
	            pq.push({v1[ind1]+v2[ind2-1],ind1,ind2-1});
	        }
	        
	    }
	    if((ind1-1)>=0 and ind2>=0){
	        strg=to_string(ind1-1)+to_string(ind2);
	        if(st.find(strg)==st.end()){
	            st.insert(strg);
	            pq.push({v1[ind1-1]+v2[ind2],ind1-1,ind2});
	        }
	        
	    }
	    
	    
	}
	
	
	

}
