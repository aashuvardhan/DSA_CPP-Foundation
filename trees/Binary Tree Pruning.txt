/*

https://leetcode.com/problems/binary-tree-pruning/



Given the root of a binary tree, return the same tree where every subtree (of the given tree) not containing a 1 has been removed.

A subtree of a node node is node plus every node that is a descendant of node.

*/



#include <bits/stdc++.h>
using namespace std;

struct Node{
    int data;
    Node* left;
    Node* right;
    Node(int x){
        data=x;
        left=NULL;
        right=NULL;
    }
};


int pruning(Node* root){
    if(root==NULL){
        return 0;
    }
    
    int ls=pruning(root->left);
    int rs=pruning(root->right);
    
    if(ls==0){
        delete(root->left);
        root->left=NULL;
    }
    if(rs==0){
        delete(root->right);
        root->right=NULL;
    }
    
    return ls | rs | root->data;
}


void inorder(Node* root){
    if(root==NULL){
        return;
    }
    inorder(root->left);
    cout<<root->data<<"  ";
    inorder(root->right);
}


int main() {
	// your code goes here

    

    Node* root=new Node(1);
    root->left=new Node(0);
    root->left->left=new Node(0);
    root->left->right=new Node(0);
    
    root->right=new Node(1);
    root->right->right=new Node(1);
    root->right->left=new Node(0);
    
    
    
    pruning(root);
    
    
    inorder(root);
    
    
    

}
